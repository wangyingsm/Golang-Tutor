# 结构体和错误

在前面我们已经介绍了数组、切片和字典的内建类型，和基本类型不同，这些类型存储的数据都不是一个标量。因此我们也可以将它们称为复合类型。但是前面介绍标量类型和这三种复合类型，都只能涉及同一种类型的数据。如果我们需要在一个数据结构中存储多种不同类型的数据的时候，前面介绍的类型都不太适合。

Go提供了结构体的类型用来存储多种类型数据的集合，结构体`struct`里可以包含除了接口类型之外的其他任何类型，每一个组成部分被称为结构体的一个字段，理论上每个字段都需要一个结构体内部唯一的名称：

```go
// 将一个struct定义为类型myStruct
type myStruct struct {
    fieldA int
    fieldB string
}
// 构建并初始化一个myStruct结构体变量
s1 := myStruct {
    fieldA: 123,
    fieldB: "a string",
}
// 构建并初始化同一个struct结构体的变量
s2 := struct {
    fieldA int
    fieldB string
}{
    fieldA: 123,
    fieldB: "a string",
}
```

从上例中，首先明确的是结构体的类型实际上是由struct关键字及其后花括号括起来的字段定义部分组成的，第一行代码的type只是为这个类型起了一个别名；然后留意初始化结构体的语法，如果你熟悉JSON和Python，这一点难度都没有，Go中的结构体变量就相当于一个JSON对象或者Python中的一个字典，因此初始化的语法也很接近（当然如果你记得Go是一门静态类型的语言的话，很显然你不能为字段设置任意类型的值）；最后我们比较一下变量s1和s2，你应该能看出这两个结构体变量的底层存储结构是一致的，而且实际上我们也为它们的所有字段设置了相同的值。

```go
// 接着上例
// 输出 {123 a string}
fmt.Println(s1)
// 输出 {123 a string}
fmt.Println(s2)
// 输出 true
fmt.Println(s1 == myStruct(s2))
```

[运行上面例子](https://goplay.space/#U1eEa63nthL)

可以看到s1和s2具有的类型是不同的，但是可以使用类型转换语法互相转换（此处将s2转换为myStruct类型），并且可以使用相等条件语法进行比较。熟悉C++或Java的读者可能会奇怪为何这个相等比较会返回true，回想[上一章](Episode.V.Function.md)我们说过，Go采用的是最简单的永远传值模式，因此这个相等比较的结构体的内容，而不是所谓的*引用*，后面[EP.VII 指针](Episode.VII.Pointer.md)一章中我们会更加深入的讨论这点。此处你只需要记住，只要没有明确使用指针或取址操作的情况下，Go变量永远代表它的值本身。